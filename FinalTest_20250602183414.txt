LLM File Collector Output
Root Directory: /Users/efxlve/Desktop/FolderToLLM-main
Execution Timestamp: 2025-06-02 18:34:14
==================================================

DIRECTORY STRUCTURE:
--------------------------------------------------
├── exampleOutput
│   └── LLM_Output_20250526140904.txt
├── .DS_Store
├── BASIT_KULLANIM.md
├── collect_and_print.sh
├── CollectAndPrint.ps1
├── DART_FLUTTER_GUIDE.md
├── debug_dart_issue.sh
├── folderToLLM.bat
├── folderToLLM.sh
├── format_output_string.sh
├── Format-OutputString.ps1
├── get_directory_structure.sh
├── get_filtered_files.sh
├── Get-DirectoryStructure.ps1
├── Get-FilteredFiles.ps1
├── install_mac.sh
├── LLM_Output_20250602183343.txt
├── MAC_ADAPTATION_SUMMARY.md
├── MacTest_Output_20250602182351.txt
├── read_text_file_content.sh
├── Read-TextFileContent.ps1
├── README_Mac.md
├── README.md
├── test_mac_version.sh
├── Test_Output_20250602182321.txt
└── USAGE_EXAMPLES_TR.md

==================================================
FILE CONTENTS:
--------------------------------------------------

--- START: /Users/efxlve/Desktop/FolderToLLM-main/README_Mac.md (6983 bytes) ---
# FolderToLLM - Mac Version

## Overview

`FolderToLLM` for Mac is a shell script-based utility designed to help you gather and consolidate project files into a single text file. This output is particularly useful for providing context to Large Language Models (LLMs) by including the directory structure and the content of selected files.

This is a Mac-compatible adaptation of the original Windows PowerShell version, providing the same functionality using bash/shell scripts that work natively on macOS and Linux systems.

## Features

*   **Directory Structure Output:** Visual tree-like representation of folders and files.
*   **File Content Aggregation:** Reads and appends the content of each selected file.
*   **Flexible Filtering:**
    *   Include/exclude specific folders (relative to the root path).
    *   Include/exclude specific file extensions (e.g., `.txt`, `.py`).
    *   Include/exclude files based on minimum or maximum size (in bytes).
*   **Default Exclusions:** By default, it excludes:
    *   `node_modules` folder.
    *   `.env` files.
    *   Files larger than 1MB.
    *   Binary files (automatically detected).
*   **Safe Content Reading:** Automatically identifies and skips binary files, and truncates very large text files to prevent memory issues.
*   **Native macOS Support:** Works with the default bash/zsh shell on macOS without requiring additional software.

## Prerequisites

*   macOS or Linux operating system
*   Bash shell (pre-installed on macOS)
*   Standard Unix utilities: `find`, `stat`, `file`, `head`, `cat` (pre-installed on macOS)

## Installation and Setup

### Option 1: Local Installation (Recommended)

1. **Download the Scripts:**
   Clone or download all the `.sh` files into a single directory:
   ```bash
   mkdir ~/FolderToLLM
   cd ~/FolderToLLM
   # Place all .sh files here
   ```

2. **Make Scripts Executable:**
   ```bash
   chmod +x *.sh
   ```

3. **Test the Installation:**
   ```bash
   ./folderToLLM.sh --help
   ```

### Option 2: Global Installation (Advanced)

1. **Move to a System Directory:**
   ```bash
   sudo mkdir -p /usr/local/bin/folderToLLM
   sudo cp *.sh /usr/local/bin/folderToLLM/
   sudo chmod +x /usr/local/bin/folderToLLM/*.sh
   ```

2. **Create a Symlink:**
   ```bash
   sudo ln -sf /usr/local/bin/folderToLLM/folderToLLM.sh /usr/local/bin/folderToLLM
   ```

3. **Use from Anywhere:**
   ```bash
   folderToLLM --help
   ```

## Usage

Navigate to the project directory you want to process and run:

```bash
./folderToLLM.sh [OPTIONS]
```

If you've installed it globally:
```bash
folderToLLM [OPTIONS]
```

### Command-Line Options

| Option | Long Option | Description | Default |
|--------|-------------|-------------|---------|
| `-r` | `--root-path` | Root directory to process | Current directory |
| `-if` | `--include-folders` | Comma-separated list of folders to include | None |
| `-ef` | `--exclude-folders` | Comma-separated list of folders to exclude | `node_modules` |
| `-ie` | `--include-extensions` | Comma-separated list of extensions to include | None |
| `-ee` | `--exclude-extensions` | Comma-separated list of extensions to exclude | `.env` |
| `-min` | `--min-file-size` | Minimum file size in bytes | No limit |
| `-max` | `--max-file-size` | Maximum file size in bytes | 1048576 (1MB) |
| `-p` | `--prefix` | Output file name prefix | `LLM_Output` |
| `-h` | `--help` | Show help message | - |

### Examples

**Process current directory with default settings:**
```bash
./folderToLLM.sh
```

**Process a specific project with custom filters:**
```bash
./folderToLLM.sh -r "/path/to/project" -ie ".js,.py,.md" -ef ".git,dist,build"
```

**Include only Python and Markdown files:**
```bash
./folderToLLM.sh --include-extensions ".py,.md"
```

**Exclude large files and logs:**
```bash
./folderToLLM.sh --max-file-size 512000 --exclude-extensions ".zip,.log,.tmp"
```

**Process only specific folders:**
```bash
./folderToLLM.sh --include-folders "src,docs,tests"
```

## Script Architecture

The Mac version consists of five shell scripts, each with a specific responsibility:

| Script | Purpose |
|--------|---------|
| `folderToLLM.sh` | Entry point script (equivalent to `folderToLLM.bat`) |
| `collect_and_print.sh` | Main orchestration script (equivalent to `CollectAndPrint.ps1`) |
| `get_directory_structure.sh` | Generates formatted directory tree (equivalent to `Get-DirectoryStructure.ps1`) |
| `get_filtered_files.sh` | Filters files based on criteria (equivalent to `Get-FilteredFiles.ps1`) |
| `read_text_file_content.sh` | Safely reads file contents (equivalent to `Read-TextFileContent.ps1`) |
| `format_output_string.sh` | Assembles final output (equivalent to `Format-OutputString.ps1`) |

## Key Differences from Windows Version

### Advantages of Mac Version:
- **Native Support:** No need to install PowerShell
- **Better Performance:** Uses native Unix tools optimized for file operations
- **Enhanced Binary Detection:** Uses the `file` command for more accurate binary file detection
- **Cross-Platform:** Works on macOS and Linux
- **Colored Output:** Enhanced terminal output with colors for better readability

### Equivalent Functionality:
- All filtering options work identically
- Output format is exactly the same
- File size limits and binary detection work similarly
- Directory structure representation is identical

## Troubleshooting

### Common Issues

**"Permission denied" errors:**
```bash
chmod +x *.sh
```

**Scripts not found:**
Ensure all `.sh` files are in the same directory and the main script can find them.

**Binary files not detected properly:**
Make sure the `file` command is available (it should be pre-installed on macOS):
```bash
which file
```

**Tree characters not displaying correctly:**
Ensure your terminal supports UTF-8 encoding. Most modern terminals do by default.

### Debug Mode

To see detailed processing information, you can modify the scripts to enable debug output by uncommenting debug lines or adding:
```bash
set -x  # Add this line to any script for verbose output
```

## Compatibility

- **macOS:** All versions with bash (10.3+)
- **Linux:** Most distributions with bash 4.0+
- **Terminal:** Any terminal that supports UTF-8 for proper tree display

## Output

The script generates a timestamped text file (e.g., `LLM_Output_20241213143022.txt`) in the specified root directory containing:

1. **Header Information:** Timestamp and root directory
2. **Directory Structure:** Tree-like representation of all folders and files
3. **File Contents:** Content of all files that match the filtering criteria

## Contributing

If you find issues with the Mac version or want to add features:

1. Test your changes on both macOS and Linux if possible
2. Ensure compatibility with different versions of bash
3. Maintain the same command-line interface as the Windows version
4. Add appropriate error handling and user feedback

## License

Same license as the original Windows version. --- END: /Users/efxlve/Desktop/FolderToLLM-main/README_Mac.md ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/install_mac.sh (2110 bytes) ---
[Binary File: install_mac.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/install_mac.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/test_mac_version.sh (2654 bytes) ---
[Binary File: test_mac_version.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/test_mac_version.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/Get-FilteredFiles.ps1 (8538 bytes) ---
﻿# Get-FilteredFiles.ps1

function Get-FilteredFileItems {
    # Function to get file items based on various filter criteria.
    param(
        [string]$RootPath,
        [string[]]$IncludeFolders = @(),
        [string[]]$ExcludeFolders = @(), # Bu parametre [".svelte-kit", "build", "node_modules", "backend"] şeklinde bir dizi olarak gelir
        [string[]]$IncludeExtensions = @(), 
        [string[]]$ExcludeExtensions = @(), 
        [long]$MinSize = -1, 
        [long]$MaxSize = -1  
    )

    Write-Host "DEBUG: Get-FilteredFileItems called." -ForegroundColor Yellow
    Write-Host "DEBUG: RootPath: $RootPath" -ForegroundColor Yellow
    Write-Host "DEBUG: IncludeFolders (raw): $($IncludeFolders -join ', ')" -ForegroundColor Yellow
    Write-Host "DEBUG: ExcludeFolders (raw): $($ExcludeFolders -join ', ')" -ForegroundColor Yellow # Bu, Write-Host'un diziyi yazdırma şekli
    Write-Host "DEBUG: IncludeExtensions (raw): $($IncludeExtensions -join ', ')" -ForegroundColor Cyan
    Write-Host "DEBUG: ExcludeExtensions (raw): $($ExcludeExtensions -join ', ')" -ForegroundColor Yellow
    Write-Host "DEBUG: MinSize: $MinSize, MaxSize: $MaxSize" -ForegroundColor Yellow

    # Normalize RootPath to an absolute path
    $absoluteRootPath = ""
    try {
        $absoluteRootPath = (Resolve-Path $RootPath -ErrorAction Stop).Path
    } catch {
        Write-Error "CRITICAL: Could not resolve RootPath: $RootPath. Aborting."
        return # Fonksiyondan çık
    }
    Write-Host "DEBUG: Absolute RootPath: $absoluteRootPath" -ForegroundColor Yellow

    $allFiles = Get-ChildItem -Path $absoluteRootPath -Recurse -File -ErrorAction SilentlyContinue
    Write-Host "DEBUG: Found $($allFiles.Count) total files initially in $absoluteRootPath." -ForegroundColor Yellow

    # Prepare a list of absolute paths for excluded folders
    $normalizedAbsoluteExcludeFolderPaths = [System.Collections.Generic.List[string]]::new()
    if ($ExcludeFolders -and $ExcludeFolders.Count -gt 0) {
        Write-Host "DEBUG: Processing ExcludeFolders array. Count: $($ExcludeFolders.Count)" -ForegroundColor DarkCyan
        foreach ($excFolderItem in $ExcludeFolders) { # $ExcludeFolders bir dizi olduğu için her elemanı tek tek işlenir
            $folderPathToResolve = Join-Path $absoluteRootPath $excFolderItem
            try {
                # Resolve-Path ile klasörün varlığını kontrol et ve tam yolunu al
                $resolvedPath = (Resolve-Path $folderPathToResolve -ErrorAction Stop).Path
                if (Test-Path $resolvedPath -PathType Container) {
                    $normalizedAbsoluteExcludeFolderPaths.Add($resolvedPath)
                    Write-Host "DEBUG: Added to Exclude List (resolved): '$excFolderItem' -> '$resolvedPath'" -ForegroundColor DarkGreen
                } else {
                    Write-Warning "Exclude folder path '$excFolderItem' (resolved to '$resolvedPath') is not a directory. It will be ignored."
                }
            } catch {
                # Resolve-Path hata verirse, klasör bulunamadı demektir. Bu bir uyarıdır, hata değil.
                Write-Warning "Could not resolve exclude folder path: '$excFolderItem' (tried as '$folderPathToResolve'). It will be ignored for exclusion."
            }
        }
        Write-Host "DEBUG: Final Normalized Absolute ExcludeFolderPaths for matching: $($normalizedAbsoluteExcludeFolderPaths -join '; ')" -ForegroundColor DarkCyan
    }

    # Prepare a list of absolute paths for included folders
    $normalizedAbsoluteIncludeFolderPaths = [System.Collections.Generic.List[string]]::new()
    if ($IncludeFolders -and $IncludeFolders.Count -gt 0) {
        Write-Host "DEBUG: Processing IncludeFolders array. Count: $($IncludeFolders.Count)" -ForegroundColor DarkCyan
        foreach ($incFolderItem in $IncludeFolders) {
            $folderPathToResolve = Join-Path $absoluteRootPath $incFolderItem
            try {
                $resolvedPath = (Resolve-Path $folderPathToResolve -ErrorAction Stop).Path
                if (Test-Path $resolvedPath -PathType Container) {
                    $normalizedAbsoluteIncludeFolderPaths.Add($resolvedPath)
                    Write-Host "DEBUG: Added to Include List (resolved): '$incFolderItem' -> '$resolvedPath'" -ForegroundColor DarkGreen
                } else {
                    Write-Warning "Include folder path '$incFolderItem' (resolved to '$resolvedPath') is not a directory. It will be ignored."
                }
            } catch {
                Write-Warning "Could not resolve include folder path: '$incFolderItem' (tried as '$folderPathToResolve'). It will be ignored for inclusion."
            }
        }
        Write-Host "DEBUG: Final Normalized Absolute IncludeFolderPaths for matching: $($normalizedAbsoluteIncludeFolderPaths -join '; ')" -ForegroundColor DarkCyan
    }


    $filteredFileResult = [System.Collections.Generic.List[System.IO.FileInfo]]::new()

    foreach ($file in $allFiles) {
        $shouldProcess = $true
        [string]$reasonForFiltering = "Passed initial check."

        # Folder Include Filter
        if ($normalizedAbsoluteIncludeFolderPaths.Count -gt 0) {
            $matchIncludeFolder = $false
            foreach ($absIncFolderPath in $normalizedAbsoluteIncludeFolderPaths) {
                if ($file.FullName.StartsWith($absIncFolderPath + [System.IO.Path]::DirectorySeparatorChar) -or $file.DirectoryName -eq $absIncFolderPath) {
                    $matchIncludeFolder = $true; break
                }
            }
            if (-not $matchIncludeFolder) {
                $shouldProcess = $false
                $reasonForFiltering = "File '$($file.FullName)' not in any included folders: $($normalizedAbsoluteIncludeFolderPaths -join ', ')"
            }
        }

        # Folder Exclude Filter
        if ($shouldProcess -and $normalizedAbsoluteExcludeFolderPaths.Count -gt 0) {
            foreach ($absExcFolderPath in $normalizedAbsoluteExcludeFolderPaths) {
                if ($file.FullName.StartsWith($absExcFolderPath + [System.IO.Path]::DirectorySeparatorChar) -or $file.DirectoryName -eq $absExcFolderPath) {
                    $shouldProcess = $false
                    $reasonForFiltering = "File '$($file.FullName)' is within excluded folder '$absExcFolderPath'."
                    break 
                }
            }
        }

        # Extension Include Filter
        if ($shouldProcess -and $IncludeExtensions.Count -gt 0) {
            $currentFileExtForDebug = $file.Extension.ToLowerInvariant() # Normalleştirilmiş uzantılarla karşılaştırmak için
            if (-not ($IncludeExtensions -contains $currentFileExtForDebug)) { # $IncludeExtensions CollectAndPrint.ps1'de normalleştirilmiş olmalı
                $shouldProcess = $false
                $reasonForFiltering = "Ext '$($file.Extension)' NOT IN IncludeExtensions '$($IncludeExtensions -join '; ')'."
            }
        }

        # Extension Exclude Filter
        if ($shouldProcess -and $ExcludeExtensions.Count -gt 0) {
            $currentFileExtForDebug = $file.Extension.ToLowerInvariant() # Normalleştirilmiş uzantılarla karşılaştırmak için
            if ($ExcludeExtensions -contains $currentFileExtForDebug) { # $ExcludeExtensions CollectAndPrint.ps1'de normalleştirilmiş olmalı
                $shouldProcess = $false
                $reasonForFiltering = "Ext '$($file.Extension)' IN ExcludeExtensions '$($ExcludeExtensions -join '; ')'."
            }
        }

        # Min Size Filter
        if ($shouldProcess -and $MinSize -ge 0) {
            if ($file.Length -lt $MinSize) {
                $shouldProcess = $false; $reasonForFiltering = "Size $($file.Length) is less than MinSize $MinSize."
            }
        }

        # Max Size Filter
        if ($shouldProcess -and $MaxSize -ge 0) {
            if ($file.Length -gt $MaxSize) {
                $shouldProcess = $false; $reasonForFiltering = "Size $($file.Length) is greater than MaxSize $MaxSize."
            }
        }

        if ($shouldProcess) {
            $filteredFileResult.Add($file)
        } else {
            # İsteğe bağlı: Her filtrelenen dosya için detaylı loglama
            # Write-Host "DEBUG: File '$($file.FullName)' FILTERED OUT. Final Reason: $reasonForFiltering" -ForegroundColor Red
        }
    }
    Write-Host "DEBUG: Get-FilteredFileItems returning $($filteredFileResult.Count) files." -ForegroundColor Yellow
    return $filteredFileResult
}--- END: /Users/efxlve/Desktop/FolderToLLM-main/Get-FilteredFiles.ps1 ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/Test_Output_20250602182321.txt (933 bytes) ---
LLM File Collector Output
Root Directory: /Users/efxlve/Desktop/FolderToLLM-main
Execution Timestamp: 2025-06-02 18:23:21
==================================================

DIRECTORY STRUCTURE:
--------------------------------------------------
├── exampleOutput
│   └── LLM_Output_20250526140904.txt
├── .DS_Store
├── collect_and_print.sh
├── CollectAndPrint.ps1
├── folderToLLM.bat
├── folderToLLM.sh
├── format_output_string.sh
├── Format-OutputString.ps1
├── get_directory_structure.sh
├── get_filtered_files.sh
├── Get-DirectoryStructure.ps1
├── Get-FilteredFiles.ps1
├── read_text_file_content.sh
├── Read-TextFileContent.ps1
├── README_Mac.md
└── README.md

==================================================
FILE CONTENTS:
--------------------------------------------------

No files matched the criteria or were found.
--- END: /Users/efxlve/Desktop/FolderToLLM-main/Test_Output_20250602182321.txt ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/BASIT_KULLANIM.md (1587 bytes) ---
# 🚀 FolderToLLM - Basit Kullanım

## 📁 Proje Klasörünüzde Terminal Açın

1. **Finder'da projenize gidin**
2. **Sağ tık > Services > New Terminal at Folder** (veya Terminal'i açıp `cd /path/to/your-project`)

## ⚡ Tek Komutla Çalıştırın

```bash
# FolderToLLM script'inin bulunduğu yerden proje klasörünüze kopyalayın
cp /path/to/FolderToLLM-main/folderToLLM.sh .
cp /path/to/FolderToLLM-main/*.sh .

# Çalıştırılabilir yapın
chmod +x *.sh

# Tek komutla çalıştırın
./folderToLLM.sh
```

## 🎯 Ne Yapar?

- **Otomatik olarak** `.dart`, `.js`, `.py`, `.md`, `.json`, `.yaml` gibi yaygın dosya tiplerini dahil eder
- **Otomatik olarak** `node_modules`, `.git`, `build` gibi gereksiz klasörleri hariç tutar
- **Proje klasörünüzde** `LLM_Output_YYYYMMDDHHMMSS.txt` dosyası oluşturur

## 🔧 Özelleştirme (İsteğe Bağlı)

```bash
# Flutter/Dart projeleri için gereksiz klasörleri hariç tutun
./folderToLLM.sh -ef ".git,build,.dart_tool,android,ios"

# Sadece belirli klasörleri dahil edin
./folderToLLM.sh -if "lib,assets"

# Dosya boyutu limitini artırın
./folderToLLM.sh -max 2000000
```

## ✅ Sonuç

Artık proje klasörünüzde sadece `./folderToLLM.sh` yazarak:
- ✅ Dart dosyalarının içeriğini alır
- ✅ Diğer kod dosyalarını dahil eder  
- ✅ Gereksiz dosyaları hariç tutar
- ✅ LLM'ye gönderebileceğiniz tek dosya oluşturur

**Bu kadar basit!** 🎉

## 🎁 Bonus: Her Projede Kullanım

Script'leri bir kez kopyaladıktan sonra her Flutter/Dart projenizde `./folderToLLM.sh` yazarak kullanabilirsiniz. --- END: /Users/efxlve/Desktop/FolderToLLM-main/BASIT_KULLANIM.md ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/format_output_string.sh (1330 bytes) ---
[Binary File: format_output_string.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/format_output_string.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/folderToLLM.bat (474 bytes) ---
﻿@echo off
REM MODIFY THIS SECTION CAREFULLY!
REM Full path to the CollectAndPrint.ps1 script:
set "MAIN_SCRIPT_PATH=C:\Tools\FolderToLLM\CollectAndPrint.ps1"

REM Run the main script using PowerShell.exe and pass all arguments (%*).
REM -NoProfile: Does not load the PowerShell profile, starts faster.
REM -ExecutionPolicy Bypass: Temporarily relaxes the execution policy (use with caution).
powershell.exe -NoProfile -ExecutionPolicy Bypass -File "%MAIN_SCRIPT_PATH%" %*--- END: /Users/efxlve/Desktop/FolderToLLM-main/folderToLLM.bat ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/Get-DirectoryStructure.ps1 (2133 bytes) ---
﻿# Get-DirectoryStructure.ps1

function Get-DirectoryStructureFormatted {
    # Function to recursively get the directory structure as a formatted string.
    param(
        [string]$Path,
        [string]$Indent = ""
    )

    $childItems = Get-ChildItem -Path $Path -ErrorAction SilentlyContinue
    # Separate directories and files and sort them by name for consistent order
    $directories = $childItems | Where-Object {$_.PSIsContainer} | Sort-Object Name
    $files = $childItems | Where-Object {!$_.PSIsContainer} | Sort-Object Name
    
    $outputLines = @() # Use an array to build lines
    
    $totalChildrenCount = $directories.Count + $files.Count
    $processedChildrenCount = 0

    # Process directories
    foreach ($dir in $directories) {
        $processedChildrenCount++
        $isThisChildTheVeryLast = ($processedChildrenCount -eq $totalChildrenCount)
        
        # Determine the prefix for the current directory entry
        $linePrefix = if ($isThisChildTheVeryLast) { "└── " } else { "├── " }
        $outputLines += "$Indent$linePrefix$($dir.Name)" # Removed backtick before $()
        
        # Determine the indent for the children of this directory
        $childIndentContinuation = if ($isThisChildTheVeryLast) { "    " } else { "│   " }
        $recursiveResult = Get-DirectoryStructureFormatted -Path $dir.FullName -Indent ($Indent + $childIndentContinuation)
        
        if (-not [string]::IsNullOrEmpty($recursiveResult)) {
            # Add the multi-line result from recursion to our output lines
            $outputLines += $recursiveResult
        }
    }

    # Process files
    foreach ($file in $files) {
        $processedChildrenCount++
        $isThisChildTheVeryLast = ($processedChildrenCount -eq $totalChildrenCount)
        
        # Determine the prefix for the current file entry
        $linePrefix = if ($isThisChildTheVeryLast) { "└── " } else { "├── " }
        $outputLines += "$Indent$linePrefix$($file.Name)" # Removed backtick before $()
    }

    # Join all collected lines with newlines
    return $outputLines -join "`n"
}--- END: /Users/efxlve/Desktop/FolderToLLM-main/Get-DirectoryStructure.ps1 ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/LLM_Output_20250602183343.txt (1230 bytes) ---
LLM File Collector Output
Root Directory: /Users/efxlve/Desktop/FolderToLLM-main
Execution Timestamp: 2025-06-02 18:33:43
==================================================

DIRECTORY STRUCTURE:
--------------------------------------------------
├── exampleOutput
│   └── LLM_Output_20250526140904.txt
├── .DS_Store
├── BASIT_KULLANIM.md
├── collect_and_print.sh
├── CollectAndPrint.ps1
├── DART_FLUTTER_GUIDE.md
├── debug_dart_issue.sh
├── folderToLLM.bat
├── folderToLLM.sh
├── format_output_string.sh
├── Format-OutputString.ps1
├── get_directory_structure.sh
├── get_filtered_files.sh
├── Get-DirectoryStructure.ps1
├── Get-FilteredFiles.ps1
├── install_mac.sh
├── MAC_ADAPTATION_SUMMARY.md
├── MacTest_Output_20250602182351.txt
├── read_text_file_content.sh
├── Read-TextFileContent.ps1
├── README_Mac.md
├── README.md
├── test_mac_version.sh
├── Test_Output_20250602182321.txt
└── USAGE_EXAMPLES_TR.md

==================================================
FILE CONTENTS:
--------------------------------------------------

No files matched the criteria or were found.
--- END: /Users/efxlve/Desktop/FolderToLLM-main/LLM_Output_20250602183343.txt ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/read_text_file_content.sh (2448 bytes) ---
[Binary File: read_text_file_content.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/read_text_file_content.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/collect_and_print.sh (7523 bytes) ---
[Binary File: collect_and_print.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/collect_and_print.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/DART_FLUTTER_GUIDE.md (3440 bytes) ---
# Flutter/Dart Projeleri için FolderToLLM Kullanım Kılavuzu

## 🎯 Dart Dosyalarının İçeriği Alınmıyor Sorunu

Dart dosyalarının içeriğini alamama sorununuz muhtemelen şu nedenlerden biri:

### ❌ Yaygın Hatalar:

1. **`.dart` uzantısını belirtmemek**
2. **Çok büyük dosya limitine takılmak**
3. **Yanlış klasör yolu vermek**

## ✅ Doğru Flutter/Dart Kullanımı

### 1. Temel Flutter Projesi
```bash
# Dart dosyalarını dahil etmek için mutlaka -ie parametresini kullanın
./folderToLLM.sh \
  -r "/path/to/your/flutter-project" \
  -ie ".dart,.yaml,.pubspec.yaml,.md" \
  -ef ".git,build,.dart_tool,android,ios"
```

### 2. Sadece Dart Kodları
```bash
# Sadece .dart dosyalarının içeriğini almak için
./folderToLLM.sh \
  -r "/path/to/your/flutter-project" \
  -ie ".dart" \
  -ef ".git,build,.dart_tool"
```

### 3. Flutter Projesi (Kapsamlı)
```bash
./folderToLLM.sh \
  -r "/path/to/your/flutter-project" \
  -ie ".dart,.yaml,.json,.md,.gitignore" \
  -ef ".git,build,.dart_tool,android/app/build,ios/Runner.xcworkspace,ios/Pods"
```

### 4. Sadece lib Klasörü
```bash
# Sadece lib klasöründeki Dart kodları
./folderToLLM.sh \
  -r "/path/to/your/flutter-project" \
  -if "lib" \
  -ie ".dart"
```

## 🔧 Sorun Giderme

### Debug Testi Çalıştırın:
```bash
chmod +x debug_dart_issue.sh
./debug_dart_issue.sh
```

### Manuel Kontrol:
```bash
# Projenizde dart dosyası var mı?
find /path/to/your/flutter-project -name "*.dart" | head -5

# Bir dart dosyasının içeriğini manuel okuyun
cat /path/to/your/flutter-project/lib/main.dart
```

## 📁 Örnek Flutter Proje Komutları

### Gerçek Dünya Örnekleri:

#### Counter App (Flutter varsayılan proje):
```bash
./folderToLLM.sh \
  -r "~/FlutterProjects/counter_app" \
  -ie ".dart,.yaml" \
  -if "lib" \
  -max 500000
```

#### E-commerce Flutter App:
```bash
./folderToLLM.sh \
  -r "~/FlutterProjects/ecommerce_app" \
  -ie ".dart,.yaml,.json" \
  -ef ".git,build,.dart_tool,android,ios,test" \
  -if "lib,assets"
```

#### Widget Kütüphanesi:
```bash
./folderToLLM.sh \
  -r "~/FlutterProjects/my_widgets" \
  -ie ".dart,.md" \
  -if "lib,example" \
  -max 200000
```

## 🚨 Önemli Notlar

### ✅ Mutlaka Yapın:
- `-ie ".dart"` parametresini kullanın
- Flutter proje yolunu `-r` ile belirtin
- `build`, `.dart_tool` klasörlerini hariç tutun

### ❌ Yapmayın:
- Extension belirtmeden çalıştırmayın
- Çok büyük dosya limitlerini kullanmayın
- Android/iOS native kodlarını dahil etmeyin (gereksiz)

## 🎯 Hızlı Test Komutu

Flutter projenizin yolunu aşağıdaki komutta değiştirip test edin:

```bash
# Bu komutu kendi proje yolunuzla değiştirin
./folderToLLM.sh \
  -r "/Users/$(whoami)/FlutterProjects/MyApp" \
  -ie ".dart,.yaml" \
  -ef ".git,build,.dart_tool" \
  -max 1000000
```

## 📊 Beklenen Sonuç

Başarılı olduğunda şunları göreceksiniz:
- `main.dart`, `app.dart` gibi dosyaların içerikleri
- Widget kodları tamamen okunabilir
- Yaml konfigürasyon dosyaları
- Proje dizin yapısı

## 🔍 Hala Çalışmıyorsa

1. **Debug scripti çalıştırın**: `./debug_dart_issue.sh`
2. **Manuel test yapın**: `cat your_flutter_project/lib/main.dart`
3. **Dosya yollarını kontrol edin**: `-r` parametresinde tam yol var mı?
4. **Extension'ı kontrol edin**: `-ie ".dart"` yazdınız mı?

Bu adımları takip ederseniz Dart dosyalarının içeriğini alabilirsiniz! 🚀 --- END: /Users/efxlve/Desktop/FolderToLLM-main/DART_FLUTTER_GUIDE.md ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/README.md (8774 bytes) ---
# FolderToLLM

## Overview

`FolderToLLM` is a PowerShell-based utility for Windows designed to help you gather and consolidate project files into a single text file. This output is particularly useful for providing context to Large Language Models (LLMs) by including the directory structure and the content of selected files.

The script will:
1.  Traverse a specified root directory (defaults to the current directory).
2.  Generate a text representation of the entire directory structure.
3.  Concatenate the content of all (or filtered) files found within that structure.
4.  Offer various filtering options to include/exclude specific folders, file extensions, and files based on size.
5.  Output everything into a timestamped `.txt` file (e.g., `LLM_Output_YYYYMMDDHHMMSS.txt`) in the root directory.

![terminal](https://cdn.goygoyengine.com/images/1747926440007-7ba82bbced04e141.gif)

## Features

*   **Directory Structure Output:** Visual tree-like representation of folders and files.
*   **File Content Aggregation:** Reads and appends the content of each selected file.
*   **Flexible Filtering:**
    *   Include/exclude specific folders (relative to the root path).
    *   Include/exclude specific file extensions (e.g., `.txt`, `.py`).
    *   Include/exclude files based on minimum or maximum size (in bytes).
*   **Default Exclusions:** By default, it excludes:
    *   `node_modules` folder.
    *   `.env` files.
    *   Files larger than 1MB.
    (These defaults can be overridden by command-line arguments).
*   **Safe Content Reading:** Attempts to identify and skip binary files, and truncates very large text files to prevent memory issues.
*   **Easy Execution:** Can be run directly or via a helper batch file for convenient access from any directory.

## Prerequisites

*   Windows Operating System.
*   PowerShell (usually comes pre-installed with Windows).

## Setup and Installation

The easiest way to use `FolderToLLM` from any directory is by using the provided `folderToLLM.bat` helper script and adding its location to your system's PATH environment variable.

1.  **Download/Clone the Repository:**
    Download all the `.ps1` files and the `folderToLLM.bat` file from this repository into a single directory on your computer. For example, you might create a folder like `C:\Tools\FolderToLLM`.

2.  **Configure `folderToLLM.bat`:**
    Open the `folderToLLM.bat` file in a text editor. You **must** update the `MAIN_SCRIPT_PATH` variable to point to the **absolute path** of the `CollectAndPrint.ps1` script in the directory where you placed the files.

    ```batch
    @echo off
    REM MODIFY THIS SECTION CAREFULLY!
    REM Full path to the CollectAndPrint.ps1 script:
    set "MAIN_SCRIPT_PATH=C:\Tools\FolderToLLM\CollectAndPrint.ps1" REM <--- UPDATE THIS PATH

    REM ... rest of the file ...
    ```
    Replace `C:\Tools\FolderToLLM\CollectAndPrint.ps1` with the actual path on your system.

3.  **Add the Script Directory to PATH (Recommended):**
    To run `folderToLLM` from any command line or PowerShell window:
    *   Search for "environment variables" in the Windows search bar and select "Edit the system environment variables."
    *   In the System Properties window, click the "Environment Variables..." button.
    *   Under "System variables" (or "User variables" if you only want it for your account), find the variable named `Path` and select it.
    *   Click "Edit...".
    *   Click "New" and add the path to the directory where you saved `folderToLLM.bat` and the `.ps1` scripts (e.g., `C:\Tools\FolderToLLM`).
    *   Click "OK" on all open dialogs to save the changes.
    *   You might need to **restart any open Command Prompt or PowerShell windows** for the PATH changes to take effect.

4.  **Ensure Script Encoding (Important for Special Characters):**
    All `.ps1` script files (`CollectAndPrint.ps1`, `Get-DirectoryStructure.ps1`, etc.) should be saved with **UTF-8 with BOM** encoding. This is crucial for correctly displaying tree characters and handling various text encodings. Most modern text editors (like VS Code, Notepad++) allow you to save files with this specific encoding.
    *   In VS Code: Click the encoding in the bottom-right status bar, select "Save with Encoding," then choose "UTF-8 with BOM."
    *   In Notepad: "File" > "Save As...", then choose "UTF-8 with BOM" from the "Encoding" dropdown.

## Usage

Once set up, open a Command Prompt or PowerShell window, navigate to the project directory you want to process, and run:

```shell
folderToLLM [arguments]
```

If run without arguments, it will process the current directory with default filters.

### Command-Line Arguments

The `CollectAndPrint.ps1` script (and thus `folderToLLM.bat`) accepts the following optional arguments:

*   `-RootPath <string>`: The root directory to process. Defaults to the current directory.
    *   Example: `folderToLLM -RootPath "C:\Projects\MyWebApp"`
*   `-IncludeFolderPaths <string[]>`: Comma-separated list of relative folder paths to include. If specified, only files within these folders (and their subfolders) will have their content read.
    *   Example: `folderToLLM -IncludeFolderPaths "src", "docs"`
*   `-ExcludeFolderPaths <string[]>`: Comma-separated list of relative folder paths to exclude.
    *   Default: `"node_modules"`
    *   Example: `folderToLLM -ExcludeFolderPaths ".git", "dist", "build"`
*   `-IncludeExtensions <string[]>`: Comma-separated list of file extensions to include (e.g., `.txt`, `.py`, `md`). The leading dot is optional.
    *   Example: `folderToLLM -IncludeExtensions ".js", ".css"`
*   `-ExcludeExtensions <string[]>`: Comma-separated list of file extensions to exclude.
    *   Default: `".env"`
    *   Example: `folderToLLM -ExcludeExtensions ".log", ".tmp", ".bak"`
*   `-MinFileSize <long>`: Minimum file size in bytes. Files smaller than this will be excluded. Use `-1` for no minimum limit.
    *   Example: `folderToLLM -MinFileSize 1024` (exclude files smaller than 1KB)
*   `-MaxFileSize <long>`: Maximum file size in bytes. Files larger than this will be excluded. Use `-1` for no maximum limit.
    *   Default: `1048576` (1MB)
    *   Example: `folderToLLM -MaxFileSize 512000` (exclude files larger than 500KB)
*   `-OutputFileNamePrefix <string>`: Prefix for the generated output file.
    *   Default: `"LLM_Output"`
    *   Example: `folderToLLM -OutputFileNamePrefix "ProjectAlpha_Snapshot"`

### Examples

*   **Process the current directory with default filters:**
    ```shell
    folderToLLM
    ```

*   **Process a specific project, only including `.py` and `.md` files, and excluding the `.venv` folder:**
    ```shell
    folderToLLM -RootPath "D:\MyPythonProject" -IncludeExtensions ".py", ".md" -ExcludeFolderPaths ".venv"
    ```

*   **Process the current directory, excluding files larger than 50KB and also excluding `.zip` files:**
    ```shell
    folderToLLM -MaxFileSize 51200 -ExcludeExtensions ".zip"
    ```

## Script Breakdown

The utility is composed of several small PowerShell scripts, each with a specific responsibility:

*   `CollectAndPrint.ps1`: The main script that orchestrates the process, handles parameters, and calls helper scripts.
*   `folderToLLM.bat`: A batch file wrapper for easy execution of `CollectAndPrint.ps1`.
*   `Get-DirectoryStructure.ps1`: Generates the formatted directory tree string.
*   `Get-FilteredFiles.ps1`: Filters files based on the provided criteria (folders, extensions, size). Contains debug logging that can be uncommented for troubleshooting.
*   `Read-TextFileContent.ps1`: Safely reads the content of text files, with checks for binary files and large files.
*   `Format-OutputString.ps1`: Assembles the final output string, including headers, directory structure, and file contents.

## Troubleshooting

*   **"Failed to load helper scripts..."**:
    *   Ensure all `.ps1` files are in the same directory as `CollectAndPrint.ps1`.
    *   Verify the `MAIN_SCRIPT_PATH` in `folderToLLM.bat` is correct.
*   **Garbled characters in directory structure (e.g., `â””â”€â”€`)**:
    *   Ensure all `.ps1` files are saved with **UTF-8 with BOM** encoding. This is the most common cause.
*   **"The term ... is not recognized as the name of a cmdlet..."**:
    *   This usually means a helper script/function was not loaded correctly. Check file paths and ensure all `.ps1` files are present and correctly encoded.
    *   Restart your PowerShell/Command Prompt window after making changes to scripts or PATH.
*   **Filters not working as expected**:
    *   Uncomment the `Write-Host` debug lines within `Get-FilteredFiles.ps1` to see detailed information about how each file is being processed and why it might be included or excluded.

--- END: /Users/efxlve/Desktop/FolderToLLM-main/README.md ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/CollectAndPrint.ps1 (6266 bytes) ---
﻿# CollectAndPrint.ps1 - Main script to collect directory structure and file contents.

[CmdletBinding()]
param(
    # Default root path to the current directory where the script is run.
    [string]$RootPath = (Get-Location).Path,

    # Folders to include. If specified, only files in these folders (and subfolders) are processed.
    [string[]]$IncludeFolderPaths = @(),

    # Folders to exclude. Default to "node_modules". User can override or add more.
    [string[]]$ExcludeFolderPaths = @("node_modules"), # Default exclusion

    # File extensions to include. If specified, only files with these extensions are processed.
    [string[]]$IncludeExtensions = @(),

    # File extensions to exclude. Default to ".env". User can override or add more.
    [string[]]$ExcludeExtensions = @(".env"), # Default exclusion

    # Minimum file size in bytes. -1 for no limit.
    [long]$MinFileSize = -1,

    # Maximum file size in bytes. Default to 1MB (1024 * 1024 bytes). -1 for no limit.
    [long]$MaxFileSize = 1048576, # Default max size: 1MB
    
    # Prefix for the output file name.
    [string]$OutputFileNamePrefix = "LLM_Output"
)

#region Parameter Pre-processing for bat file compatibility
# Handle array parameters that might come as a single comma-separated string from cmd.exe via .bat file
if ($IncludeFolderPaths.Count -eq 1 -and $IncludeFolderPaths[0] -match ',') {
    Write-Host "DEBUG: Splitting IncludeFolderPaths from single string: $($IncludeFolderPaths[0])" -ForegroundColor Magenta
    $IncludeFolderPaths = $IncludeFolderPaths[0].Split(',') | ForEach-Object {$_.Trim()} | Where-Object {$_}
}
if ($ExcludeFolderPaths.Count -eq 1 -and $ExcludeFolderPaths[0] -match ',') {
    Write-Host "DEBUG: Splitting ExcludeFolderPaths from single string: $($ExcludeFolderPaths[0])" -ForegroundColor Magenta
    $ExcludeFolderPaths = $ExcludeFolderPaths[0].Split(',') | ForEach-Object {$_.Trim()} | Where-Object {$_}
}
if ($IncludeExtensions.Count -eq 1 -and $IncludeExtensions[0] -match ',') {
    Write-Host "DEBUG: Splitting IncludeExtensions from single string: $($IncludeExtensions[0])" -ForegroundColor Magenta
    $IncludeExtensions = $IncludeExtensions[0].Split(',') | ForEach-Object {$_.Trim()} | Where-Object {$_}
}
if ($ExcludeExtensions.Count -eq 1 -and $ExcludeExtensions[0] -match ',') {
    Write-Host "DEBUG: Splitting ExcludeExtensions from single string: $($ExcludeExtensions[0])" -ForegroundColor Magenta
    $ExcludeExtensions = $ExcludeExtensions[0].Split(',') | ForEach-Object {$_.Trim()} | Where-Object {$_}
}
#endregion

# Dot-source the helper scripts to make their functions available.
# Ensure these .ps1 files are in the same directory as this script, or provide full paths.
try {
    . "$PSScriptRoot\Get-DirectoryStructure.ps1"
    . "$PSScriptRoot\Get-FilteredFiles.ps1"
    . "$PSScriptRoot\Read-TextFileContent.ps1"
    . "$PSScriptRoot\Format-OutputString.ps1"
}
catch {
    Write-Error "Failed to load helper scripts. Ensure they are in the same directory: $PSScriptRoot. Error: $($_.Exception.Message)"
    exit 1
}

Write-Host "Processing directory: $RootPath"
Write-Host "Effective IncludeFolderPaths: $($IncludeFolderPaths -join ', ')" # For verification
Write-Host "Effective ExcludeFolderPaths: $($ExcludeFolderPaths -join ', ')"
Write-Host "Effective IncludeExtensions: $($IncludeExtensions -join ', ')"   # For verification
Write-Host "Effective ExcludeExtensions: $($ExcludeExtensions -join ', ')"
Write-Host "Effective MaxFileSize: $MaxFileSize bytes"


# 1. Get Directory Structure
Write-Host "Generating directory structure..."
$directoryStructureString = Get-DirectoryStructureFormatted -Path $RootPath

# 2. Get Filtered Files
Write-Host "Filtering files..."
# Normalize extension filters (ensure they start with a dot and are lowercase)
# This normalization should happen AFTER splitting if they came as a single string
$normalizedIncludeExtensions = @($IncludeExtensions | ForEach-Object { ($_.Trim().ToLowerInvariant() -replace '^\*?(?!\.)','.') } | Where-Object {$_})
$normalizedExcludeExtensions = @($ExcludeExtensions | ForEach-Object { ($_.Trim().ToLowerInvariant() -replace '^\*?(?!\.)','.') } | Where-Object {$_})

Write-Host "Normalized IncludeExtensions: $($normalizedIncludeExtensions -join ', ')"
Write-Host "Normalized ExcludeExtensions: $($normalizedExcludeExtensions -join ', ')"

# Ensure $filteredFileItems is always an array.
# Explicitly pass parameters to Get-FilteredFileItems.
$filteredFileItems = @(Get-FilteredFileItems -RootPath $RootPath `
                                            -IncludeFolders $IncludeFolderPaths `
                                            -ExcludeFolders $ExcludeFolderPaths `
                                            -IncludeExtensions $normalizedIncludeExtensions `
                                            -ExcludeExtensions $normalizedExcludeExtensions `
                                            -MinSize $MinFileSize `
                                            -MaxSize $MaxFileSize)

Write-Host "Found $($filteredFileItems.Count) files matching criteria."

# 3. Format the output (File contents will be read by Format-OutputString via the scriptblock)
Write-Host "Formatting output..."
$finalOutput = New-FormattedOutput -RootDirectory $RootPath `
    -DirectoryStructure $directoryStructureString `
    -FileItems $filteredFileItems `
    -ContentReader { param($FileItem) Read-SafeTextFileContent -FileItem $FileItem }

# 4. Output to File
$timestamp = Get-Date -Format "yyyyMMddHHmmss"
$outputFilePath = Join-Path -Path $RootPath -ChildPath "$($OutputFileNamePrefix)_$timestamp.txt"

try {
    Write-Host "Writing output to: $outputFilePath"
    $finalOutput | Out-File -FilePath $outputFilePath -Encoding UTF8 -Force
    Write-Host "Successfully generated output file."
}
catch {
    Write-Error "Failed to write output file: $($_.Exception.Message)"
}

# Optional: Display a snippet or confirmation
if ((Test-Path $outputFilePath) -and (Get-Item $outputFilePath).Length -lt 20000) {
    Write-Host "`n--- Output File Preview (first 20 lines) ---"
    Get-Content $outputFilePath -TotalCount 20
} elseif (Test-Path $outputFilePath) {
    Write-Host "`nOutput file is large. Preview skipped."
}

Write-Host "Script finished."--- END: /Users/efxlve/Desktop/FolderToLLM-main/CollectAndPrint.ps1 ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/Read-TextFileContent.ps1 (2217 bytes) ---
﻿# Read-TextFileContent.ps1

function Read-SafeTextFileContent {
    # Function to safely read text file content.
    # For very large files or binary files, it might return a placeholder or partial content.
    param(
        [Parameter(Mandatory=$true)]
        [System.IO.FileInfo]$FileItem,
        [long]$MaxCharsToRead = 1000000 # Limit reading to avoid memory issues with huge files, approx 1MB for UTF-8
    )

    try {
        # Basic check for common binary extensions - can be expanded
        $binaryExtensions = @(".exe", ".dll", ".zip", ".gz", ".tar", ".jpg", ".png", ".gif", ".bmp", ".iso", ".mp3", ".mp4", ".pdf", ".doc", ".xls", ".ppt") # .doc, .xls, .ppt are often binary
        if ($binaryExtensions -contains $FileItem.Extension.ToLowerInvariant()) {
            return "[Binary File: $($FileItem.Name) - Content not displayed]"
        }

        if ($FileItem.Length -eq 0) {
            return "[Empty File: $($FileItem.Name)]"
        }
        
        # Attempt to read as text
        # Using -Raw is faster for reading the whole file
        # We'll use Get-Content with -TotalCount for char limit if necessary
        if ($FileItem.Length -gt ($MaxCharsToRead * 2)) { # Approximation, actual characters depends on encoding
             Write-Warning "File $($FileItem.FullName) is very large ($($FileItem.Length) bytes). Reading up to $MaxCharsToRead characters."
             $content = Get-Content -Path $FileItem.FullName -TotalCount ($MaxCharsToRead / 200) -ErrorAction SilentlyContinue # Approx lines
             # This is a rough way to limit characters, better to read byte stream and decode
             if ($content -is [array]) { $content = $content -join "`n" }
             if ($content.Length -gt $MaxCharsToRead) {
                $content = $content.Substring(0, $MaxCharsToRead) + "... [TRUNCATED]"
             }
             return $content
        } else {
            return Get-Content -Path $FileItem.FullName -Raw -ErrorAction SilentlyContinue
        }
    }
    catch {
        # If Get-Content fails (e.g., encoding issue, locked file)
        return "[Error Reading File: $($FileItem.Name) - $($_.Exception.Message)]"
    }
}

# Removed Export-ModuleMember--- END: /Users/efxlve/Desktop/FolderToLLM-main/Read-TextFileContent.ps1 ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/Format-OutputString.ps1 (1831 bytes) ---
﻿# Format-OutputString.ps1

function New-FormattedOutput {
    # Function to create the final formatted output string.
    param(
        [string]$RootDirectory,
        [string]$DirectoryStructure,
        [System.Collections.IEnumerable]$FileItems, # Collection of FileInfo objects
        [scriptblock]$ContentReader # Scriptblock to call for reading content, e.g., { Read-SafeTextFileContent -FileItem $_ }
    )

    $outputBuilder = New-Object System.Text.StringBuilder

    [void]$outputBuilder.AppendLine("LLM File Collector Output")
    [void]$outputBuilder.AppendLine("Root Directory: $RootDirectory")
    [void]$outputBuilder.AppendLine("Execution Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')")
    [void]$outputBuilder.AppendLine("=" * 50)
    [void]$outputBuilder.AppendLine()
    [void]$outputBuilder.AppendLine("DIRECTORY STRUCTURE:")
    [void]$outputBuilder.AppendLine("-" * 50)
    [void]$outputBuilder.AppendLine($DirectoryStructure)
    [void]$outputBuilder.AppendLine()
    [void]$outputBuilder.AppendLine("=" * 50)
    [void]$outputBuilder.AppendLine("FILE CONTENTS:")
    [void]$outputBuilder.AppendLine("-" * 50)
    [void]$outputBuilder.AppendLine()

    if ($FileItems) {
        foreach ($fileItem in $FileItems) {
            [void]$outputBuilder.AppendLine("--- START: $($fileItem.FullName) ($($fileItem.Length) bytes) ---")
            $content = . $ContentReader -FileItem $fileItem # Invoke the provided scriptblock
            [void]$outputBuilder.AppendLine($content)
            [void]$outputBuilder.AppendLine("--- END: $($fileItem.FullName) ---")
            [void]$outputBuilder.AppendLine()
        }
    } else {
        [void]$outputBuilder.AppendLine("No files matched the criteria or were found.")
    }
    
    return $outputBuilder.ToString()
}

# Removed Export-ModuleMember--- END: /Users/efxlve/Desktop/FolderToLLM-main/Format-OutputString.ps1 ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/debug_dart_issue.sh (2177 bytes) ---
[Binary File: debug_dart_issue.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/debug_dart_issue.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/MacTest_Output_20250602182351.txt (1004 bytes) ---
LLM File Collector Output
Root Directory: /Users/efxlve/Desktop/FolderToLLM-main
Execution Timestamp: 2025-06-02 18:23:51
==================================================

DIRECTORY STRUCTURE:
--------------------------------------------------
├── exampleOutput
│   └── LLM_Output_20250526140904.txt
├── .DS_Store
├── collect_and_print.sh
├── CollectAndPrint.ps1
├── folderToLLM.bat
├── folderToLLM.sh
├── format_output_string.sh
├── Format-OutputString.ps1
├── get_directory_structure.sh
├── get_filtered_files.sh
├── Get-DirectoryStructure.ps1
├── Get-FilteredFiles.ps1
├── read_text_file_content.sh
├── Read-TextFileContent.ps1
├── README_Mac.md
├── README.md
├── test_mac_version.sh
└── Test_Output_20250602182321.txt

==================================================
FILE CONTENTS:
--------------------------------------------------

No files matched the criteria or were found.
--- END: /Users/efxlve/Desktop/FolderToLLM-main/MacTest_Output_20250602182351.txt ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/folderToLLM.sh (731 bytes) ---
[Binary File: folderToLLM.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/folderToLLM.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/get_filtered_files.sh (5756 bytes) ---
[Binary File: get_filtered_files.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/get_filtered_files.sh ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/MAC_ADAPTATION_SUMMARY.md (3883 bytes) ---
# FolderToLLM Mac Adaptation - Complete Summary

## ✅ Adaptation Completed Successfully

Your Windows PowerShell project has been successfully adapted for Mac/macOS! The Mac version provides identical functionality to the original Windows version using native bash shell scripts.

## 📁 New Mac Files Created

### Core Scripts
- **`folderToLLM.sh`** - Main entry point (replaces `folderToLLM.bat`)
- **`collect_and_print.sh`** - Main orchestration script (replaces `CollectAndPrint.ps1`)
- **`get_directory_structure.sh`** - Directory tree generator (replaces `Get-DirectoryStructure.ps1`)
- **`get_filtered_files.sh`** - File filtering logic (replaces `Get-FilteredFiles.ps1`)
- **`read_text_file_content.sh`** - Safe file content reader (replaces `Read-TextFileContent.ps1`)
- **`format_output_string.sh`** - Output formatter (replaces `Format-OutputString.ps1`)

### Documentation & Setup
- **`README_Mac.md`** - Comprehensive Mac-specific documentation
- **`install_mac.sh`** - Automated installation script
- **`test_mac_version.sh`** - Test script to verify functionality

## 🚀 Quick Start for Mac Users

### 1. Installation
```bash
chmod +x *.sh
./install_mac.sh
```

### 2. Basic Usage
```bash
# Show help
./folderToLLM.sh --help

# Process current directory with defaults
./folderToLLM.sh

# Custom filtering examples
./folderToLLM.sh -ie ".js,.py,.md" -ef ".git,node_modules,dist"
```

## 🔧 Technical Implementation Details

### Key Adaptations Made:

1. **Shell Script Architecture**: Replaced PowerShell with bash/shell scripts
2. **Command-Line Parsing**: Implemented full argument parsing with long/short options
3. **File Operations**: Used native Unix tools (`find`, `stat`, `file`, etc.)
4. **Cross-Platform Compatibility**: Added macOS-specific file size detection
5. **Enhanced Binary Detection**: Improved binary file detection using `file` command
6. **Colored Output**: Added terminal colors for better user experience

### Maintained Features:
- ✅ Identical command-line interface
- ✅ Same filtering options (folders, extensions, file sizes)
- ✅ Same output format
- ✅ Binary file detection and exclusion
- ✅ Large file handling and truncation
- ✅ Default exclusions (node_modules, .env files)

### Mac-Specific Improvements:
- **Native Performance**: Uses optimized Unix tools
- **No Dependencies**: Works with pre-installed macOS utilities
- **Better Error Handling**: Enhanced error messages and validation
- **Colored Terminal Output**: Visual feedback during processing

## 📊 Verification Results

✅ **All scripts created successfully**  
✅ **Help system working**  
✅ **File filtering functional**  
✅ **Directory structure generation working**  
✅ **Output file creation successful**  
✅ **Content formatting correct**

The adaptation has been tested and verified to work correctly on macOS.

## 🔄 Usage Comparison

| Task | Windows | Mac |
|------|---------|-----|
| Show Help | `folderToLLM --help` | `./folderToLLM.sh --help` |
| Process Directory | `folderToLLM` | `./folderToLLM.sh` |
| Custom Filters | `folderToLLM -IncludeExtensions ".js",".py"` | `./folderToLLM.sh -ie ".js,.py"` |
| Exclude Folders | `folderToLLM -ExcludeFolderPaths ".git","dist"` | `./folderToLLM.sh -ef ".git,dist"` |

## 📖 Next Steps

1. **Test the scripts** on your specific projects
2. **Customize default exclusions** if needed
3. **Consider global installation** for convenience
4. **Share with Mac/Linux users** in your team

## 🎯 Benefits of Mac Version

- **No PowerShell Required**: Works with native bash/zsh
- **Better Performance**: Optimized for Unix file systems
- **Cross-Platform**: Works on both macOS and Linux
- **Enhanced Features**: Improved binary detection and colored output
- **Easy Distribution**: Single directory with all files

Your FolderToLLM project is now fully cross-platform compatible! 🎉 --- END: /Users/efxlve/Desktop/FolderToLLM-main/MAC_ADAPTATION_SUMMARY.md ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/USAGE_EXAMPLES_TR.md (3392 bytes) ---
# FolderToLLM Mac - Türkçe Kullanım Örnekleri

## 🎯 Sadece Belirli Bir Projeyi İşlemek

Scriptiniz **varsayılan olarak çalıştırıldığı dizini** işler. Sadece belirli bir projenizi işlemek için `-r` (root path) parametresini kullanın:

## 📁 Temel Kullanım

### 1. Belirli Bir Projeyi İşlemek
```bash
# Masaüstünüzdeki bir projeyi işleyin
./folderToLLM.sh -r "/Users/kullaniciadi/Desktop/MyProject"

# Documents klasöründeki bir projeyi işleyin
./folderToLLM.sh -r "~/Documents/WebProject"

# Geçerli konumdan farklı bir dizindeki projeyi işleyin
./folderToLLM.sh -r "/path/to/your/project"
```

### 2. Proje Tipine Göre Örnekler

#### React/Next.js Projesi
```bash
./folderToLLM.sh \
  -r "/Users/kullaniciadi/Desktop/ReactProject" \
  -ie ".js,.jsx,.ts,.tsx,.json,.md,.css" \
  -ef "node_modules,.next,dist,build,.git"
```

#### Python Projesi
```bash
./folderToLLM.sh \
  -r "/Users/kullaniciadi/Documents/PythonProject" \
  -ie ".py,.md,.txt,.yml,.yaml,.json" \
  -ef ".venv,__pycache__,.git,dist,build"
```

#### Vue.js Projesi
```bash
./folderToLLM.sh \
  -r "~/Projects/VueProject" \
  -ie ".vue,.js,.ts,.json,.md,.css,.scss" \
  -ef "node_modules,dist,.git"
```

#### Laravel/PHP Projesi
```bash
./folderToLLM.sh \
  -r "/Users/kullaniciadi/Sites/LaravelProject" \
  -ie ".php,.blade.php,.js,.css,.md,.json" \
  -ef "vendor,node_modules,storage/logs,public/storage,.git"
```

#### Swift/iOS Projesi
```bash
./folderToLLM.sh \
  -r "~/XcodeProjects/MyApp" \
  -ie ".swift,.m,.h,.md,.plist" \
  -ef ".build,DerivedData,*.xcworkspace,Pods,.git"
```

## 🔧 Gelişmiş Filtreleme

### 3. Sadece Kaynak Kodları
```bash
# Sadece kod dosyaları, dokümantasyon hariç
./folderToLLM.sh \
  -r "/path/to/project" \
  -ie ".js,.ts,.jsx,.tsx,.py,.php,.swift,.java,.cpp,.c,.h"
```

### 4. Sadece Dokümantasyon
```bash
# Sadece README, dokümantasyon dosyaları
./folderToLLM.sh \
  -r "/path/to/project" \
  -ie ".md,.txt,.rst,.adoc"
```

### 5. Belirli Klasörleri Dahil Etmek
```bash
# Sadece src ve docs klasörlerini işle
./folderToLLM.sh \
  -r "/path/to/project" \
  -if "src,docs,components"
```

### 6. Küçük Dosyalar İçin
```bash
# Sadece 100KB'dan küçük dosyalar
./folderToLLM.sh \
  -r "/path/to/project" \
  -max 102400
```

## 🚨 Önemli Notlar

### ✅ Doğru Kullanım:
```bash
# ✅ Bu şekilde sadece belirttiğiniz projeyi işler
./folderToLLM.sh -r "/Users/kullaniciadi/Desktop/MyProject"
```

### ❌ Yanlış Kullanım:
```bash
# ❌ Bu şekilde script'in bulunduğu dizini işler (tüm Mac değil ama istemediğiniz yer)
./folderToLLM.sh
```

## 📂 Gerçek Örnek Senaryo

Diyelim ki masaüstünüzde "ECommerceApp" adında bir projeniz var:

```bash
# Projenizin tam yolunu kullanın
./folderToLLM.sh -r "/Users/$(whoami)/Desktop/ECommerceApp"

# Veya kısaca
./folderToLLM.sh -r "~/Desktop/ECommerceApp"

# Sadece önemli dosyaları dahil etmek için
./folderToLLM.sh \
  -r "~/Desktop/ECommerceApp" \
  -ie ".js,.jsx,.ts,.tsx,.json,.md,.css" \
  -ef "node_modules,dist,build,.git,.env"
```

## 🎯 Sonuç

- Script **sadece belirttiğiniz dizini** işler
- `-r` parametresi ile **tam proje yolunu** verin
- **Mac'inizin tamamını** işlemez, endişelenmeyin
- Çıktı dosyası **belirttiğiniz proje dizininde** oluşur

Bu şekilde sadece istediğiniz projeyi LLM'ye göndermek için hazırlamış olursunuz! 🚀 --- END: /Users/efxlve/Desktop/FolderToLLM-main/USAGE_EXAMPLES_TR.md ---

--- START: /Users/efxlve/Desktop/FolderToLLM-main/get_directory_structure.sh (1961 bytes) ---
[Binary File: get_directory_structure.sh - Content not displayed]
--- END: /Users/efxlve/Desktop/FolderToLLM-main/get_directory_structure.sh ---
